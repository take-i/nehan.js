/*
 if <body>[float1][float2][other elements]</body>
 style of this generator is 'body.context.style'.
 */
Nehan.FloatGenerator = (function(){
  /**
     @memberof Nehan
     @class FloatGenerator
     @classdesc generator of float layout
     @constructor
     @param context {Nehan.RenderingContext}
  */
  function FloatGenerator(context){
    Nehan.LayoutGenerator.call(this, context);
  }

  // float generator itself is only mediator for float-targets and float-spaces,
  // and it has no original edge or box level.
  // so we extends not block-geneartor but layout-generator.
  Nehan.Class.extend(FloatGenerator, Nehan.LayoutGenerator);

  // before: [root] -> [space] -> [child]
  //  after: [root] -> [child]
  FloatGenerator.prototype._updateChildParent = function(){
    if(this.context.hasNextFloat()){
      return;
    }
    //console.info("FloatGenerator::_updateChildParent");
    if(this.context.child.hasCache()){
      //console.log("inherit child cache:", this.context.child.peekLastCache());
      this.context.parent.pushCache(this.context.child.popCache());
    }
    if(this.context.child.child){
      this.context.child.child.updateParent(this.context.parent);
    }
  };

  FloatGenerator.prototype._yield = function(){
    //console.log("FloatGen::_yield");
    if(this.context.hasCache()){
      //console.log("FloatGen, use cache");
      return this._popCache();
    }
    var stack = this.context.yieldFloatStack();

    // If stack is empty but there are still active float elements, it's overflow.
    if(stack.isEmpty() && this.context.hasNextFloat()){
      //console.warn("float-target is empty, but has next, so retry in next page");
      return this.context.yieldPageBreak();
    }

    var stack_extent = stack.getExtent();
    var rest_measure = this.context.layoutContext.getInlineRestMeasure();
    if(stack_extent > this.context.getContextMaxExtent()){
      //console.warn("float stack can't be included in parent layout! -> break-after");
      this.context.pushFloatStackCache(stack);
      return this.context.yieldPageBreak();
    }

    return this._yieldFloat(stack, rest_measure, stack_extent);
  };

  // note that final form of this function is always finished by iniline wrap set.
  FloatGenerator.prototype._yieldFloat = function(stack, rest_measure, stack_extent){
    //console.log("_yieldFloat(rest_m:%d, rest_e:%d)", rest_measure, stack_extent);

    // no more rest space
    if(rest_measure <= 0 || stack_extent <= 0){
      //console.warn("no more rest space:(m=%d, e=%d)", rest_measure, stack_extent);
      this._updateChildParent();
      //console.warn("return null");
      return null;
    }

    // no more floated layout, just yield rest area.
    if(stack.isEmpty()){
      //console.warn("no more floating elements");
      return this.context.yieldFloatSpace(stack.getLastGroup(), rest_measure, stack_extent);
    }
    /*
      <------ rest_measure ---->
      --------------------------
      |       |                |
      | group | rest           | => group_set(inline wrap set)
      |       |                |
      --------------------------
    */
    var flow = this.context.style.flow;
    var prev_group = stack.getLastGroup();
    var group = stack.pop(flow); // pop float group(notice that this stack is ordered by extent asc, so largest one is first obtained).
    var rest = this._yieldFloat(stack, rest_measure - group.getMeasure(flow), group.getExtent(flow)); // yield rest area of this group in inline-flow(recursive).
    var group_set = this._wrapInlineSet(group, rest, rest_measure); // wrap these 2 floated layout as one block.

    /*
      To understand rest_extent_space, remember that this func is called recursivelly,
      and argument 'stack_extent' is generated by 'previous' largest float group(g2).
      
      <--- rest_measure --->
      ----------------------------
      |    |                |    |
      | g1 | rest           | g2 |
      |    |                |    |
      ----------------------|    |
      |  rest_extent_space  |    |
      ----------------------------
    */
    var rest_extent_space = stack_extent - group.getExtent(flow);

    // if no more rest extent is left,
    // continuous layout is displayed in parent context.
    if(rest_extent_space <= 0){
      //console.warn("no more rest extent, group set:%o", group_set);
      this._updateChildParent();
      return group_set;
    }

    //console.log("rest extent space:%d", rest_extent_space);

    /*
      <------ rest_measure ---->
      --------------------------
      |       |                |
      | group | rest           | => group_set(inline wrap set)
      |       |                |
      --------------------------
      |  rest_extent_space     | => stack_extent - group_set.extent
      --------------------------
    */
    // if there is space in block direction, yield rest space and wrap them([inline wrap set, rest_extent_space]).
    var space = this.context.yieldFloatSpace(prev_group, rest_measure, rest_extent_space);
    return this._wrapBlockSet([group_set, space]);
  };

  FloatGenerator.prototype._sortFloatRest = function(floated, rest){
    var floated_elements = floated.getElements();
    var elements = floated.isFloatStart()? floated_elements.concat(rest) : [rest].concat(floated_elements);
    return elements.filter(function(element){
      return element !== null;
    });
  };

  // wrap.measure = e1.measure + e2.measure
  // wrap.extent = max(e1.extent, e2.extent)
  // [wrap][e1][e2][/wrap]
  FloatGenerator.prototype._wrapInlineSet = function(floated, rest, measure){
    var flow = this.context.style.flow;
    var elements = this._sortFloatRest(floated, rest || null);
    var extent = (elements.length > 0)? floated.getExtent(flow) : 0;
    var box = this.context.yieldWrapBlock(measure, extent, elements);
    // break after is available only while floated targets are alive.
    box.breakAfter = this.context.hasNextFloat();
    //console.warn("wrap inline set:", box);
    return box;
  };

  // wrap.measure = e1.measure = e2.measure
  // wrap.extent = e1.extent + e2.extent
  // [wrap]
  // [ e1 ]
  // [ e2 ]
  // [/wrap]
  FloatGenerator.prototype._wrapBlockSet = function(blocks){
    var flow = this.context.style.flow;
    var elements = blocks.filter(function(block){ return block !== null; });
    var measure = elements[0].getLayoutMeasure(flow); // block1 and block2 has same measure
    var extent = Nehan.List.sum(elements, 0, function(element){ return element.getLayoutExtent(flow); });
    var box = this.context.yieldWrapBlock(measure, extent, elements);
    //console.warn("wrap block set:", box);
    return box;
  };

  return FloatGenerator;
})();

